#事务的四个关键属性:
1.原子性:事务是一个原子操作,由一系列动作组成,事务的原子性确保动作要么全部完成要么完全不起作用
2.一致性:一旦所有事务动作完成,事务就被提交.数据和资源就处于一种满足业务规则的一致性状态中
3.隔离性:可能有许多事务会同时处理相同的数据,因此每个事务都应该与其他事务隔离开来,防止数据损坏
4.持久性:一旦事务完成,无论发生什么系统错误,它的结果都不应该受影响.通常情况下事务的结果被写到持久化存储器中
#spring中的事务管理
编程式事务管理:将事务管理的代码嵌入到业务方法中来控制事务的提交和回滚,在编程式事务管理时,必须在每个事务操作中包含额外的事务管理代码
声明式事务管理:事务管理作为一种横切关注点,通过aop模块化
spring的核心事务管理是PlatformTransactionManager接口
用事务通知声明式的事务管理
<tx:advice transaction-manager="transactionManager">
    <tx:attributes>
    </tx:attributes>
</tx:advice>
#spring事务的传播属性 PROPAGATION
当事务方法被另一个事务调用时,必须指定事务应该如何传播,事务的传播行为可以由传播属性指定
REQUIRED:当前存在事务,则加入该事务,否则创建新事务
REQUIRES_NEW:创建一个新事物,如果当前存在事务,则把当前事务挂起
SUPPORTS:如果当前存在事务,则加入该事务,否则以非事务的方式运行
NOT_SUPPORTED:以非事务方式运行,如果当前存在事务,则把该事物挂起
NERVER:以非事务方式运行,如果当前存在事务,则抛出异常
MANDATORY:如果当前存在事务,则加入;当前不存在事务,则抛出异常
NESTED:如果当前存在事务,则创建一个事务作为当前事务的嵌套事务来运行;如果当前不存在事务,则该值等价于REQUIRED
#spring事务的隔离属性 ISOLATION
DEFAULT:默认值,使用底层数据库的默认隔离级别
READ_COMMIT:该隔离级别表示一个事务只能读取另一个事务已经提交的数据.可以防止脏读
READ_UNCOMMIT:该级别表示一个事务可以读取到另一个事务修改但还没有提交的数据.该级别不能防止脏读和不可重复读
REPEATABLE_READ:该级别表示一个事务在整个过程中可以多次重复执行某个查询,并且每次返回的结果都相同,即使在多次查询之间有新增的数据满足该查询,新增的记录也
会被忽略,该级别可以防止脏读和不可重复读
SERIALIZABLE:所有的事务依次逐个执行,这样事务之间就不可能干扰,该级别可以防止脏读,幻读,不可重复读,但是这将严重影响程序的性能
多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量所发出的方法调用在编程时并不确定,而是在运行期间才会确定,即一个引用变量到底会指向哪个类的实例.
native方法表示该方法需要依赖另外一种平台语言才能实现,不存在着被子类访问的问题.
synchronized使用在一个具体的方法上才有意义,而且所使用的的的同步锁是this,而抽象方法无法确定this是什么.
可以存储和操作字符串,,即包含多个字符的字符数据,string类提供了数值不可改变的字符串.而stringBuffer类的字符串可以进行修改.
return调用先于finally,finally中的代码比return和break后执行.
运行时异常表示虚拟机的通常操作中可能遇到的异常,是一种常见的错误.
hashmap是hashtable的轻量级实现,都完成了map接口,hashmap允许null的key或者value,而hashtable不可以,hashmap把hashtable中的contains方法去掉了,改成
containsValue和containsKey,hashtable基于陈旧的dictionary类,而hashmap是map接口的一个实现.
java对象从一个字节流恢复成一个java对象,实现searializable接口的类,javac在编译时会进行特殊处理,编译的类才可以被writeObject方法操作.
类的装载是由ClassLoader和它的子类类实现的,负责在运行时装载和查找类文件.
#heap(堆)&&stack(栈)
stack 栈 分配的内存系统自动释放,静态分配内存
      	      Heap(堆)	      Stack(栈)
 JVM中的功能	     内存数据区    	               内存指令区
 存储数据	     对象实例(1)	 基本数据类型, 指令代码,常量,对象的引用地址(2)
    函数中定义的一些基本变量和对象的引用变量都在栈内存中分配.栈内存中主要存放的是基本数据类型和对象值,在栈内存中
    数据的大小及生命周期是必须确定的,优点是寄存速度快,栈数据可以共享,缺点是数据固定不够灵活
heap 堆 动态分配内存
    堆内存用来存放所有的new创建的对象和数组的数据
java中内存分为堆内存和栈内存,栈内存是指程序进入一个方法时,会为这个方法单独分配一块私有的存储空间,用于存储这个方法内部的局部变量,当这个方法结束后,分配给
这个方法的栈会释放,这个栈中的变量也将随之释放.
堆一般存放不放在当前方法栈中的数据,new创建的对象都放在堆里,方法中的局部变量使用final修饰后,放在堆中而不是栈中.
final关键字修饰一个变量时,是指引用变量不能变,引用变量所指向的对象中的内容还是可以改变的.
web应用就是通过http协议对网页浏览器发送的请求进行响应的服务器或服务.
一个web服务器对请求响应的典型步骤:
1.服务器对客户端发来的请求进行解析
2.请求被转发给一个预定义的处理器
3.处理器可能会从数据库中取出数据
4.处理器根据取出的数据对模板进行渲染
5.处理器向客户端返回渲染后的内容作为对请求的响应
#HTTPS
https是安全的http,http协议中的内容都是明文传输,https的目的是将这些内容加密,确保信息传输安全,最后一个字母s指的是ssl/tls协议,它位于http和tcp/ip之间
(https)超文本传输安全协议,经由http进行通信,利用ssl/tls来加密数据包,主要的目的是提供对网络服务器的身份验证,保证交换数据的隐私和完整性
1.客户端发出请求,请求中包括支持的协议版本,一个客户端生成的随机数,支持的加密方法,支持的压缩方法
2.服务器回应,确认使用的加密通信协议,一个服务器生成的随机数(稍后用于生成对话密钥),确认使用的加密方法,服务器证书
3.客户端回应,客户端收到服务器回应后,首先验证服务器证书,如果证书不是可信任的机构颁布,或者证书的域名与实际的域名不一致,或者证书已经过期,就会向访问者发出
一个警告,尤其选择是否还要继续通信.如果证书没有问题,就会从证书中取出服务器的公钥然后再向服务器发送信息
一个随机数,该随机数用于公钥加密防止被窃听,编码改变通知表示随后的信息都将用双方商定的加密方法和密钥发送,客户端握手结束通知
4.服务器的最后回应,编码改变通知,服务器端握手结束通知
cookie用来记录用户的身份,由少量的数据组成,要求浏览器存储这些数据,并在每次服务发送请求后将这些数据传回给服务.
cookie是一种发送到客户浏览器的文本串句柄,并保存在客户机硬盘上,可以用来在某个web站点会话期间持久的保持数据
session指在服务器端保存的一个数据结构,用来跟踪用户的状态,这个数据可以保存在集群,数据库,文件中;
cookie是客户端保存用户信息的一种机制,用来记录用户的信息,也是实现session的一种方式
