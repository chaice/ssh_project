#事务的四个关键属性:
1.原子性:事务是一个原子操作,由一系列动作组成,事务的原子性确保动作要么全部完成要么完全不起作用
2.一致性:一旦所有事务动作完成,事务就被提交.数据和资源就处于一种满足业务规则的一致性状态中
3.隔离性:可能有许多事务会同时处理相同的数据,因此每个事务都应该与其他事务隔离开来,防止数据损坏
4.持久性:一旦事务完成,无论发生什么系统错误,它的结果都不应该受影响.通常情况下事务的结果被写到持久化存储器中
#spring中的事务管理
编程式事务管理:将事务管理的代码嵌入到业务方法中来控制事务的提交和回滚,在编程式事务管理时,必须在每个事务操作中包含额外的事务管理代码
声明式事务管理:事务管理作为一种横切关注点,通过aop模块化
spring的核心事务管理是PlatformTransactionManager接口
用事务通知声明式的事务管理
<tx:advice transaction-manager="transactionManager">
    <tx:attributes>
    </tx:attributes>
</tx:advice>
#spring事务的传播属性
当事务方法被另一个事务调用时,必须指定事务应该如何传播,事务的传播行为可以由传播属性指定
REOUIRED:如果有事务在运行,当前方法
多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量所发出的方法调用在编程时并不确定,而是在运行期间才会确定,即一个引用变量到底会指向哪个类的实例.
native方法表示该方法需要依赖另外一种平台语言才能实现,不存在着被子类访问的问题.
synchronized使用在一个具体的方法上才有意义,而且所使用的的的同步锁是this,而抽象方法无法确定this是什么.
可以存储和操作字符串,,即包含多个字符的字符数据,string类提供了数值不可改变的字符串.而stringBuffer类的字符串可以进行修改.
return调用先于finally,finally中的代码比return和break后执行.
运行时异常表示虚拟机的通常操作中可能遇到的异常,是一种常见的错误.
hashmap是hashtable的轻量级实现,都完成了map接口,hashmap允许null的key或者value,而hashtable不可以,hashmap把hashtable中的contains方法去掉了,改成
containsValue和containsKey,hashtable基于陈旧的dictionary类,而hashmap是map接口的一个实现.
java对象从一个字节流恢复成一个java对象,实现searializable接口的类,javac在编译时会进行特殊处理,编译的类才可以被writeObject方法操作.
类的装载是由ClassLoader和它的子类类实现的,负责在运行时装载和查找类文件.
#heap(堆)&&stack(栈)
java中内存分为堆内存和栈内存,栈内存是指程序进入一个方法时,会为这个方法单独分配一块私有的存储空间,用于存储这个方法内部的局部变量,当这个方法结束后,分配给
这个方法的栈会释放,这个栈中的变量也将随之释放.
堆一般存放不放在当前方法栈中的数据,new创建的对象都放在堆里,方法中的局部变量使用final修饰后,放在堆中而不是栈中.
final关键字修饰一个变量时,是指引用变量不能变,引用变量所指向的对象中的内容还是可以改变的.
web应用就是通过http协议对网页浏览器发送的请求进行响应的服务器或服务.
一个web服务器对请求响应的典型步骤:
1.服务器对客户端发来的请求进行解析
2.请求被转发给一个预定义的处理器
3.处理器可能会从数据库中取出数据
4.处理器根据取出的数据对模板进行渲染
5.处理器向客户端返回渲染后的内容作为对请求的响应

cookie用来记录用户的身份,由少量的数据组成,要求浏览器存储这些数据,并在每次服务发送请求后将这些数据传回给服务.
