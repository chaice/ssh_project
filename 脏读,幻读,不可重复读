脏读:当一个事务正在访问数据,并且正在对数据进行更改,而这种更改还没有提交到数据库,这时,另一个事务也访问了该数据,然后使用了该数据.
不可重复读:是指在一个事务内,多次读取同一个数据.另一个事务也访问该数据.那么在第一个事务的两次读取数据之间,由于第二个事务的修改,那么第一个事务读取的两次
数据可能是不一样的.
幻读:是指事务不是独立执行时发生的一种现象.例如,第一个事务对一个表的数据进行了修改,这种修改涉及到表中的全部数据.同时,第二个事务也修改这个表中的数据,这种
修改是向表中插入一行新数据.操作第一个事务的用户发现表中还有没有修改的数据行,就像是产生了幻觉一样.

丢失更新:两个事务同时更新同一数据,最后一个事务会覆盖掉第一个事务的更新,从而导致第一个事务更新的数据丢失.

事务的隔离级别:
read uncommitted    可能会出现脏读,幻读,不可重复读
read committed  可能出现不可重复读,幻读
repeatable 可能出现幻读
serializable 都不会出现

#悲观锁
悲观锁:悲观并发控制是一种并发控制的方法,它可以阻止一个事务以影响其他用户的方式来修改数据.如果一个事务的执行某行数据使用了锁,那只有当这个事务把锁释放,其他
事务才能够执行与该锁冲突的操作.主要用于数据争用激烈的环境,以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本.悲观锁的实现,往往要靠数据库提供的锁
机制,也只有数据库层提供的锁机制才能真正保证数据访问的排他性.
悲观锁的流程:在对任意记录进行修改之前,先尝试为该记录加上排他锁.如果加锁失败,说明该记录正在被修改,那么当前查询可能要等待或者抛出异常.如果成功加锁,那么就
可以对记录做修改,事务完成后就解锁了.期间如果有其他要对该记录修改或加锁的操作,都会等待解锁或直接抛出异常.
要使用悲观锁必须关闭数据库的自动提交属性. set autocommit=0;
select ... for update 这样就通过开启排他锁的方式实现了悲观锁.
**行级锁都是基于索引的,用不到索引是不会使用行级锁的.而是会使用表级锁把整张表给锁住.
缺点:处理加锁的机制会让数据库产生额外的开销,还会增加死锁的机会.只读性事务处理中,由于不会产生冲突,没必要使用锁.降低了并行性,一个事务锁定了某行数据,其他事
务必须等待该事务处理完才能处理.

#乐观锁(不能防范脏数据)
乐观锁---乐观并发控制,假设多用户并发的事务在处理时不会彼此影响,各事务能够在不产生锁的情况下处理各自影响的那部分数据.在提交数据更新之前,每个事务会先检查
在该事务读取数据后,有没有其他事务又修改了该数据.如果其他事务有更新的话,正在提交的事务会进行回滚.
在对数据库进行处理的时候,乐观锁并不会使用数据库提供的锁机制,一般实现乐观锁的方式是记录数据版本.
数据版本---为数据增加的一个版本标识.在读取数据时,将版本标识的值一同读出,数据没更新一次,同时对版本标识进行更新.当提交更新的时候,判断数据库表对应记录的当
前版本信息与第一次取出来的版本标识进行对比,如果数据库表当前版本号与第一次取出来的版本标识值相等,则予以更新,否则认为是过期数据.
实现数据版本有两种方式,第一使用版本号,第二使用时间戳.
